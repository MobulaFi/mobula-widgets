{"id":"uCGZ","dependencies":[{"name":"C:\\Users\\Veeno\\Desktop\\fse\\react-widget\\package.json","includedInParent":true,"mtime":1662043584758},{"name":"C:\\Users\\Veeno\\Desktop\\fse\\react-widget\\node_modules\\@supabase\\realtime-js\\package.json","includedInParent":true,"mtime":1661947879660},{"name":"./lib/constants","loc":{"line":1,"column":47,"index":47},"parent":"C:\\Users\\Veeno\\Desktop\\fse\\react-widget\\node_modules\\@supabase\\realtime-js\\dist\\module\\RealtimeSubscription.js","resolved":"C:\\Users\\Veeno\\Desktop\\fse\\react-widget\\node_modules\\@supabase\\realtime-js\\dist\\module\\lib\\constants.js"},{"name":"./lib/push","loc":{"line":2,"column":17,"index":83},"parent":"C:\\Users\\Veeno\\Desktop\\fse\\react-widget\\node_modules\\@supabase\\realtime-js\\dist\\module\\RealtimeSubscription.js","resolved":"C:\\Users\\Veeno\\Desktop\\fse\\react-widget\\node_modules\\@supabase\\realtime-js\\dist\\module\\lib\\push.js"},{"name":"./lib/timer","loc":{"line":3,"column":18,"index":115},"parent":"C:\\Users\\Veeno\\Desktop\\fse\\react-widget\\node_modules\\@supabase\\realtime-js\\dist\\module\\RealtimeSubscription.js","resolved":"C:\\Users\\Veeno\\Desktop\\fse\\react-widget\\node_modules\\@supabase\\realtime-js\\dist\\module\\lib\\timer.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;var e=require(\"./lib/constants\"),t=s(require(\"./lib/push\")),i=s(require(\"./lib/timer\"));function s(e){return e&&e.__esModule?e:{default:e}}class n{constructor(s,n={},o){this.topic=s,this.params=n,this.socket=o,this.bindings=[],this.state=e.CHANNEL_STATES.closed,this.joinedOnce=!1,this.pushBuffer=[],this.timeout=this.socket.timeout,this.joinPush=new t.default(this,e.CHANNEL_EVENTS.join,this.params,this.timeout),this.rejoinTimer=new i.default(()=>this.rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive(\"ok\",()=>{this.state=e.CHANNEL_STATES.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(e=>e.send()),this.pushBuffer=[]}),this.onClose(()=>{this.rejoinTimer.reset(),this.socket.log(\"channel\",`close ${this.topic} ${this.joinRef()}`),this.state=e.CHANNEL_STATES.closed,this.socket.remove(this)}),this.onError(t=>{this.isLeaving()||this.isClosed()||(this.socket.log(\"channel\",`error ${this.topic}`,t),this.state=e.CHANNEL_STATES.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive(\"timeout\",()=>{this.isJoining()&&(this.socket.log(\"channel\",`timeout ${this.topic}`,this.joinPush.timeout),this.state=e.CHANNEL_STATES.errored,this.rejoinTimer.scheduleTimeout())}),this.on(e.CHANNEL_EVENTS.reply,(e,t)=>{this.trigger(this.replyEventName(t),e)})}rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout(),this.socket.isConnected()&&this.rejoin()}subscribe(e=this.timeout){if(this.joinedOnce)throw\"tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance\";return this.joinedOnce=!0,this.rejoin(e),this.joinPush}onClose(t){this.on(e.CHANNEL_EVENTS.close,t)}onError(t){this.on(e.CHANNEL_EVENTS.error,e=>t(e))}on(e,t){this.bindings.push({event:e,callback:t})}off(e){this.bindings=this.bindings.filter(t=>t.event!==e)}canPush(){return this.socket.isConnected()&&this.isJoined()}push(e,i,s=this.timeout){if(!this.joinedOnce)throw`tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;let n=new t.default(this,e,i,s);return this.canPush()?n.send():(n.startTimeout(),this.pushBuffer.push(n)),n}updateJoinPayload(e){this.joinPush.updatePayload(e)}unsubscribe(i=this.timeout){this.state=e.CHANNEL_STATES.leaving;let s=()=>{this.socket.log(\"channel\",`leave ${this.topic}`),this.trigger(e.CHANNEL_EVENTS.close,\"leave\",this.joinRef())};this.joinPush.destroy();let n=new t.default(this,e.CHANNEL_EVENTS.leave,{},i);return n.receive(\"ok\",()=>s()).receive(\"timeout\",()=>s()),n.send(),this.canPush()||n.trigger(\"ok\",{}),n}onMessage(e,t,i){return t}isMember(e){return this.topic===e}joinRef(){return this.joinPush.ref}rejoin(t=this.timeout){this.isLeaving()||(this.socket.leaveOpenTopic(this.topic),this.state=e.CHANNEL_STATES.joining,this.joinPush.resend(t))}trigger(t,i,s){let{close:n,error:o,leave:r,join:h}=e.CHANNEL_EVENTS;if(s&&[n,o,r,h].indexOf(t)>=0&&s!==this.joinRef())return;let u=this.onMessage(t,i,s);if(i&&!u)throw\"channel onMessage callbacks must return the payload, modified or unmodified\";this.bindings.filter(e=>\"*\"===e.event?t===(null==i?void 0:i.type):e.event===t).map(e=>e.callback(u,s))}replyEventName(e){return`chan_reply_${e}`}isClosed(){return this.state===e.CHANNEL_STATES.closed}isErrored(){return this.state===e.CHANNEL_STATES.errored}isJoined(){return this.state===e.CHANNEL_STATES.joined}isJoining(){return this.state===e.CHANNEL_STATES.joining}isLeaving(){return this.state===e.CHANNEL_STATES.leaving}}exports.default=n;"},"sourceMaps":null,"error":null,"hash":"1a59cada44713d58dac30a6ad257a093","cacheData":{"env":{}}}